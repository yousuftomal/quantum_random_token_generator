# -*- coding: utf-8 -*-
"""Quantum Random Token Generator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DHChStZ00-Xwv076ObyDuFrj7k2dCG1-
"""

# Install required packages
!pip install qiskit qiskit-aer numpy scipy

# Check Qiskit version
import qiskit
print("Qiskit version:", qiskit.__version__)

from qiskit import QuantumCircuit
from qiskit_aer import Aer
from qiskit.circuit.library import RZZGate
import numpy as np
from scipy.stats import chi2, norm

# Define the alphanumeric character set (62 characters: A-Z, a-z, 0-9)
CHAR_SET = (
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    'abcdefghijklmnopqrstuvwxyz'
    '0123456789'
)
CHAR_COUNT = len(CHAR_SET)  # 62

# Function to convert bits to a character
def bits_to_char(bits):
    value = int(bits, 2) % CHAR_COUNT
    return CHAR_SET[value]

# Quantum Random Token Generator with improved circuit
def generate_random_token(num_chars=32, shots=10, qubits_per_batch=12):
    bits_per_char = 6
    total_bits = num_chars * bits_per_char  # 192 bits for 32 characters
    bits_per_run = qubits_per_batch
    num_runs = (total_bits + bits_per_run - 1) // bits_per_run  # Ceiling division

    tokens = []
    all_bitstrings = []

    for shot in range(shots):
        token_bits = ''
        for _ in range(num_runs):
            # Create quantum circuit
            qc = QuantumCircuit(qubits_per_batch, qubits_per_batch)

            # Step 1: Apply Hadamard gates for superposition
            for i in range(qubits_per_batch):
                qc.h(i)

            # Step 2: Add multiple layers of entangling and rotation gates
            for layer in range(2):  # Two layers for deeper circuit
                # Rzz gates with varied angles
                for i in range(0, qubits_per_batch - 1, 2):
                    qc.append(RZZGate(theta=np.pi / (2 ** layer)), [i, i+1])

                # CNOT gates for additional entanglement
                for i in range(0, qubits_per_batch - 1):
                    qc.cx(i, (i + 1) % qubits_per_batch)  # Circular connectivity

                # Random single-qubit rotations
                for i in range(qubits_per_batch):
                    qc.rx(np.pi * np.random.random(), i)
                    qc.ry(np.pi * np.random.random(), i)

            # Step 3: Add Toffoli gates
            for i in range(0, qubits_per_batch - 2, 3):
                qc.ccx(i, i+1, i+2)

            # Step 4: Final Hadamard layer
            for i in range(qubits_per_batch):
                qc.h(i)

            # Step 5: Measure
            qc.measure(range(qubits_per_batch), range(qubits_per_batch))

            # Simulate
            simulator = Aer.get_backend('qasm_simulator')
            job = simulator.run(qc, shots=1)
            result = job.result()
            counts = result.get_counts()
            bitstring = list(counts.keys())[0]
            token_bits += bitstring

        # Truncate to exact number of bits needed
        token_bits = token_bits[:total_bits]
        all_bitstrings.append(token_bits)

        # Convert bits to token
        token = ''
        for i in range(0, total_bits, bits_per_char):
            chunk = token_bits[i:i+bits_per_char]
            if len(chunk) == bits_per_char:
                token += bits_to_char(chunk)  # Fixed typo here
        tokens.append(token[:num_chars])

        # Debug: Print bitstring statistics
        ones = token_bits.count('1')
        print(f"Shot {shot+1}: {len(token_bits)} bits, {ones} ones ({ones/len(token_bits):.2%})")

    return tokens, all_bitstrings

# Randomness Quality Tests
def frequency_test(bitstring):
    n = len(bitstring)
    ones = bitstring.count('1')
    zeros = n - ones
    expected = n / 2
    chi_square = ((ones - expected) ** 2 + (zeros - expected) ** 2) / expected
    p_value = 1 - chi2.cdf(chi_square, df=1)
    return p_value > 0.05, p_value  # Return pass/fail and p-value

def runs_test(bitstring):
    n = len(bitstring)
    runs = 1
    for i in range(1, n):
        if bitstring[i] != bitstring[i-1]:
            runs += 1
    ones = bitstring.count('1')
    zeros = n - ones
    if ones == 0 or zeros == 0:
        return False, 0.0
    expected_runs = 2 * ones * zeros / n + 1
    variance = (2 * ones * zeros * (2 * ones * zeros - n)) / (n ** 2 * (n - 1))
    z = abs(runs - expected_runs) / np.sqrt(variance)
    p_value = 2 * (1 - norm.cdf(z))
    return p_value > 0.05, p_value  # Return pass/fail and p-value

# Generate and test tokens
tokens, bitstrings = generate_random_token(num_chars=32, shots=10, qubits_per_batch=12)
print("\nGenerated Tokens:")
for i, token in enumerate(tokens):
    print(f"Token {i+1}: {token}")

# Perform randomness tests on bitstrings
print("\nRandomness Quality Tests:")
for i, bits in enumerate(bitstrings):
    freq_pass, freq_p = frequency_test(bits)
    runs_pass, runs_p = runs_test(bits)
    print(f"Bitstring {i+1}:")
    print(f"  Frequency Test: {'Pass' if freq_pass else 'Fail'} (p-value: {freq_p:.4f})")
    print(f"  Runs Test: {'Pass' if runs_pass else 'Fail'} (p-value: {runs_p:.4f})")